<html>
<style>
* {
    background-color: #101020;
    color: ghostwhite;
}
</style>
<h1>RPNCalc V4 Public Testing</h1>
<p>@ me (aidanprattewart@protonmail.com) if you have any errors, with console output please.</p>
<textarea type="text" id="inbox"></textarea>
<button id="submit">execute</button>
<pre id="outbox"></pre>
<script src="./main.js" type="module"></script>
<p>
<h2>Docs</h2>
<h3>Lambda Syntax</h3>
lambda: <code>a b -> b a</code>
parensed lambda: <code>(a -> a)</code>
<h3>Let-In Syntax</h3>
not called immediately; call-by-name
<br>
let: <code>(name; value1 value2)</code> N.B. when called, applies (pushes) both values to the stack
<br>
example named function: <code>(++; x -> x 1 +)</code>
<h3>Pairings</h3>
<code>1 2 pair</code> evaluates to <code>{1, 2}</code>
<br>
can call <code>fst</code> and <code>snd</code> on pairs
<h3>Partials</h3>
<code>'+</code> pushes (not applies) a closure onto the stack
<br>
<code>1 +</code> is a partially applied function/closure
<h3>Type Literals</h3>
Essentialy strings.
<br>
Example useage: <code>"1 "int unsafeCoerce 1 +</code>
<h3>Equality</h3>
Internaly JS-based, derived for all objects, pushes lambdas representing true and false onto the stack.
<br>
For example: <code>"true-option "false-option val1 val2 ==</code>
<h2>Examples</h2>
factorial: <code>(!; x -> 1 '(-> x 1 - ! x *) x 0 ==)</code>
<br>
fold (stops at type literal <code>"stop</code>): <code>(fold; x acc fn -> '(-> acc) '(-> x acc fn 'fn fold) 'x \"stop ==)</code>
</p>
</html>